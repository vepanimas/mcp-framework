import { writeFile, mkdir, readFile, copyFile } from 'fs/promises';
import { join, relative, dirname, basename } from 'path';
import { DiscoveredTool } from './ToolDiscovery.js';

export interface GenerationConfig {
  projectRoot: string;
  toolsDirectory: string;
  outputDirectory: string;
  serverName: string;
  serverVersion: string;
  transport: 'stdio' | 'http';
  port?: number;
}

export class ServerGenerator {
  constructor(private config: GenerationConfig) {}

  async generateServer(tools: DiscoveredTool[]): Promise<string> {
    const validTools = tools.filter(tool => tool.isValid);
    
    const serverCode = this.generateServerCode(validTools);
    const packageJson = this.generatePackageJson();
    const tsConfig = this.generateTsConfig();

    // Ensure output directory exists
    await mkdir(this.config.outputDirectory, { recursive: true });

    // Copy tool files to generated directory
    await this.copyToolFiles(validTools);
    
    // Write generated files
    await this.writeGeneratedFiles(serverCode, packageJson, tsConfig);
    
    return join(this.config.outputDirectory, 'server.ts');
  }

  private generateServerCode(tools: DiscoveredTool[]): string {
    const imports = this.generateImports(tools);
    const toolRegistrations = this.generateToolRegistrations(tools);
    const contextProvider = this.generateContextProvider();

    return `#!/usr/bin/env node
// Generated MCP Server
// Do not edit this file manually - it will be overwritten
// Generated at: ${new Date().toISOString()}

import type { ToolContext, ToolResult } from './base-classes.js';
${imports}

${contextProvider}

// Simple MCP server implementation
const tools = new Map();

// Register discovered tools
async function registerTools() {
${toolRegistrations}
}

// Basic MCP protocol handler
function handleMCPMessage(message: any) {
  return new Promise(async (resolve, reject) => {
    try {
      if (message.method === 'tools/list') {
        resolve({
          jsonrpc: '2.0',
          id: message.id,
          result: {
            tools: Array.from(tools.entries()).map(([name, config]) => ({
              name,
              description: config.description,
              inputSchema: config.schema
            }))
          }
        });
      } else if (message.method === 'tools/call') {
        const name = message.params?.name;
        if (!name || !tools.has(name)) {
          reject({ code: -1, message: \`Unknown tool: \${name}\` });
          return;
        }

        const toolConfig = tools.get(name);
        try {
          const validatedInput = toolConfig.schema.parse(message.params?.arguments || {});
          const result = await toolConfig.handler(validatedInput);
          resolve({
            jsonrpc: '2.0',
            id: message.id,
            result
          });
        } catch (error) {
          reject({ code: -2, message: \`Tool execution failed: \${error instanceof Error ? error.message : String(error)}\` });
        }
      } else {
        reject({ code: -3, message: \`Unknown method: \${message.method}\` });
      }
    } catch (error) {
      reject({ code: -4, message: \`Server error: \${error instanceof Error ? error.message : String(error)}\` });
    }
  });
}

// Start server
async function startServer() {
  try {
    await registerTools();
    console.log('‚úÖ MCP server started successfully');
    console.log(\`üìã Registered \${tools.size} tools: \${Array.from(tools.keys()).join(', ')}\`);
    
    // Handle stdio communication
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', async (data) => {
      try {
        const message = JSON.parse(data.toString().trim());
        const response = await handleMCPMessage(message);
        process.stdout.write(JSON.stringify(response) + '\\n');
      } catch (error) {
        const errorResponse = {
          jsonrpc: '2.0',
          id: null,
          error: error
        };
        process.stdout.write(JSON.stringify(errorResponse) + '\\n');
      }
    });
    
    process.stdin.resume();
  } catch (error) {
    console.error('‚ùå Failed to start MCP server:', error);
    process.exit(1);
  }
}

startServer().catch(console.error);
`;
  }

  private generateImports(tools: DiscoveredTool[]): string {
    return tools
      .map(tool => {
        const fileName = basename(tool.filePath, '.ts');
        return `import ${tool.className} from './${fileName}.js';`;
      })
      .join('\n');
  }

  private generateToolRegistrations(tools: DiscoveredTool[]): string {
    return tools
      .map(tool => {
        return `  // Register ${tool.className} (${tool.toolName})
  try {
    const ${tool.className.toLowerCase()}Instance = new ${tool.className}();
    tools.set(${tool.className.toLowerCase()}Instance.name, {
      description: ${tool.className.toLowerCase()}Instance.description,
      schema: ${tool.className.toLowerCase()}Instance.schema,
      handler: async (input) => {
        const context = await getToolContext();
        try {
          const result = await ${tool.className.toLowerCase()}Instance.execute(input, context);
          return result;
        } catch (error) {
          console.error(\`Error executing tool \${${tool.className.toLowerCase()}Instance.name}:\`, error);
          return {
            content: [{
              type: 'text',
              text: \`Error: \${error instanceof Error ? error.message : 'Unknown error'}\`
            }]
          };
        }
      }
    });
    console.log('‚úÖ Registered tool:', ${tool.className.toLowerCase()}Instance.name);
  } catch (error) {
    console.error('‚ùå Failed to register ${tool.className}:', error);
  }`;
      })
      .join('\n\n');
  }

  private generateContextProvider(): string {
    return `
// Tool context provider
async function getToolContext(): Promise<ToolContext> {
  const { readdir } = await import('fs/promises');
  const { join } = await import('path');
  const { execSync } = await import('child_process');

  let workspaceFiles: string[] = [];
  let gitInfo: any = undefined;

  try {
    // Simple file discovery (could be enhanced)
    const scanDir = async (dir: string, maxDepth: number = 2): Promise<string[]> => {
      if (maxDepth <= 0) return [];
      const files: string[] = [];
      try {
        const entries = await readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
          if (entry.name.startsWith('.')) continue;
          const fullPath = join(dir, entry.name);
          if (entry.isFile()) {
            files.push(fullPath);
          } else if (entry.isDirectory() && maxDepth > 1) {
            files.push(...await scanDir(fullPath, maxDepth - 1));
          }
        }
      } catch (error) {
        // Ignore permission errors
      }
      return files;
    };

    workspaceFiles = await scanDir('${this.config.projectRoot}');
  } catch (error) {
    console.warn('Could not scan workspace files:', error);
  }

  try {
    // Get git info
    const branch = execSync('git rev-parse --abbrev-ref HEAD', { 
      encoding: 'utf8', 
      cwd: '${this.config.projectRoot}',
      stdio: 'pipe'
    }).trim();
    
    const hasChanges = execSync('git status --porcelain', { 
      encoding: 'utf8', 
      cwd: '${this.config.projectRoot}',
      stdio: 'pipe'
    }).trim().length > 0;

    let remoteUrl;
    try {
      remoteUrl = execSync('git config --get remote.origin.url', { 
        encoding: 'utf8', 
        cwd: '${this.config.projectRoot}',
        stdio: 'pipe'
      }).trim();
    } catch (error) {
      // No remote configured
    }

    gitInfo = {
      branch,
      hasUncommittedChanges: hasChanges,
      remoteUrl
    };
  } catch (error) {
    // Not a git repository or git not available
  }

  return {
    projectRoot: '${this.config.projectRoot}',
    currentFile: undefined, // Could be enhanced with IDE integration
    workspaceFiles,
    gitInfo
  };
}`;
  }

  private generatePackageJson(): string {
    return JSON.stringify({
      name: `${this.config.serverName}-mcp-server`,
      version: this.config.serverVersion,
      description: `Generated MCP server for ${this.config.serverName}`,
      type: 'module',
      main: 'dist/server.js',
      scripts: {
        start: 'node dist/server.js',
        build: 'tsc',
        'build:watch': 'tsc --watch'
      },
      dependencies: {
        '@modelcontextprotocol/sdk': '^1.15.1',
        'zod': '^3.23.8'
      },
      devDependencies: {
        'typescript': '^5.3.3',
        '@types/node': '^20.17.28'
      }
    }, null, 2);
  }

  private generateTsConfig(): string {
    return JSON.stringify({
      compilerOptions: {
        target: 'ES2022',
        module: 'Node16',
        moduleResolution: 'Node16',
        outDir: './dist',
        rootDir: '.',
        declaration: true,
        strict: false,
        noImplicitAny: false,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        resolveJsonModule: true,
        allowSyntheticDefaultImports: true
      },
      include: [
        '**/*.ts'
      ],
      exclude: [
        'node_modules',
        'dist'
      ]
    }, null, 2);
  }

  private async copyToolFiles(tools: DiscoveredTool[]): Promise<void> {
    // Create base classes file
    const baseClassesContent = `import { z } from 'zod';

export interface ToolContext {
  projectRoot: string;
  currentFile?: string;
  workspaceFiles: string[];
  gitInfo?: {
    branch: string;
    hasUncommittedChanges: boolean;
    remoteUrl?: string;
  };
}

export interface ToolResult {
  content: Array<{
    type: string;
    text?: string;
    data?: string;
    mimeType?: string;
  }>;
}

export abstract class MCPTool {
  abstract readonly name: string;
  abstract readonly description: string;
  abstract readonly schema: z.ZodType;
  abstract execute(input: any, context?: ToolContext): Promise<ToolResult>;

  protected textResponse(text: string): ToolResult {
    return {
      content: [{ type: 'text', text }]
    };
  }

  protected jsonResponse(data: any): ToolResult {
    return {
      content: [{ type: 'text', text: JSON.stringify(data, null, 2) }]
    };
  }

  protected errorResponse(error: string): ToolResult {
    return {
      content: [{ type: 'text', text: \`Error: \${error}\` }]
    };
  }
}
`;
    
    await writeFile(join(this.config.outputDirectory, 'base-classes.ts'), baseClassesContent);
    
    // Copy and modify each tool file
    for (const tool of tools) {
      const content = await readFile(tool.filePath, 'utf-8');
      const modifiedContent = content.replace(
        "from 'mcp-framework/codegen'",
        "from './base-classes.js'"
      );
      const fileName = basename(tool.filePath);
      await writeFile(join(this.config.outputDirectory, fileName), modifiedContent);
    }
  }

  private async writeGeneratedFiles(
    serverCode: string, 
    packageJson: string, 
    tsConfig: string
  ): Promise<void> {
    await writeFile(join(this.config.outputDirectory, 'server.ts'), serverCode);
    await writeFile(join(this.config.outputDirectory, 'package.json'), packageJson);
    await writeFile(join(this.config.outputDirectory, 'tsconfig.json'), tsConfig);
  }

  private getRelativeImportPath(toolFilePath: string): string {
    // Convert absolute tool file path to relative import path from the generated server
    const relativePath = relative(this.config.outputDirectory, toolFilePath);
    // Remove .ts extension and ensure it starts with ./ or ../
    const importPath = relativePath.replace(/\.ts$/, '.js');
    return importPath.startsWith('.') ? importPath : `./${importPath}`;
  }
}